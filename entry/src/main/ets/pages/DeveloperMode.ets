// ç®¡ç†é¡µï¼šåˆ—è¡¨ã€ç¼–è¾‘ã€åˆ é™¤å…¥å£
import router from '@system.router';
import promptAction from '@ohos.promptAction';
import { MemoryItem, MemoryType, DateLike } from '../types/MemoryTypes';
import { MemoryDBUtil, Memory, makeValuesBucket } from '../utils/MemDBUtils';
import { relationalStore } from '@kit.ArkData';
import { formatDate as formatDateUtil } from '../utils/dateUtils';
import vibrator from '@ohos.vibrator';
import pasteboard from '@ohos.pasteboard';
import { notificationManager } from '@kit.NotificationKit';

interface MemoryExportItem { title: string; date: number | string | null; type: MemoryType; }
interface MemoryImportItem { title?: string; date?: number | string | null; type?: string; }
// Narrowing type for possible publish() errors
interface BusinessErrorLike { code?: number | string; message?: string }

@Entry
@Component
export struct ManageMemories {
  @State events: MemoryItem[] = [];
  @State deleteTargetId: number | undefined = undefined;
  @State busy: boolean = false;
  // ç»Ÿä¸€çš„å¯¼å…¥/å¯¼å‡ºæ–‡æœ¬æ¡†ä¸æ¨¡å¼
  @State ioText: string = '';
  @State isExportMode: boolean = true;

  onInit(): void {
    // Load from DB at start
    this.loadEvents();
  }

  // no MemoryStore subscription; refresh from DB on lifecycle hooks

  onDestroy(): void {
    // no-op
  }

  onShow(): void {
    this.loadEvents();
  }

  // å½“æ­¤é¡µé¢å³å°†æ˜¾ç¤ºæ—¶è°ƒç”¨ï¼ˆæ¯”ä¾èµ–è¿”å›å¯¼èˆªæ›´å®‰å…¨ï¼‰
  aboutToAppear(): void {
    // åˆ·æ–°ä¸¤æ¬¡ï¼šç«‹å³åˆ·æ–°ï¼Œç„¶åçŸ­æš‚å»¶è¿Ÿåå†æ¬¡åˆ·æ–°ï¼Œä»¥æ•è·æœ€è¿‘çš„æ•°æ®åº“æäº¤
    this.loadEvents();
    setTimeout(() => this.loadEvents(), 300);
  }

  build() {
    Column({ space: 16 }) {
      // Header
      Column() {
        Text('è°ƒè¯•æ¨¡å¼')
          .fontSize(20)
          .fontWeight(FontWeight.Bold)
          .fontColor('#111')
          .margin({ top: 18 });
        Text('ä»…åœ¨å¼€å‘è€…æŒ‡å¯¼ä¸‹è°ƒè¯•ä½¿ç”¨ï¼Œæ…é‡æ“ä½œï¼ï¼ï¼')
          .fontSize(12)
          .fontColor('#9AA0A6')
          .margin({ top: 6, bottom: 6 });
      }
      .alignItems(HorizontalAlign.Center)

      // Action buttons row
      Row({ space: 10 }) {
        Button('â• æ–°å¢æµ‹è¯•æ•°æ®')
          .type(ButtonType.Normal)
          .backgroundColor('#1677FF')
          .fontColor('#FFFFFF')
          .onClick(() => this.testWrite())
          .layoutWeight(1)
          .height(40);

        Button('ğŸ§¹ æ¸…ç†å…¨éƒ¨æ•°æ®')
          .type(ButtonType.Normal)
          .backgroundColor('#FF4D4F')
          .fontColor('#FFFFFF')
          .onClick(() => this.clearAll())
          .layoutWeight(1)
          .height(40);
      }
      .padding({ left: 16, right: 16 })

      Row({ space: 10 }) {
        Button('ğŸ“¤ å¯¼å‡ºæ—¥å¿—')
          .type(ButtonType.Normal)
          .backgroundColor('#00AA66')
          .fontColor('#FFFFFF')
          .onClick(() => this.exportLogs())
          .layoutWeight(1)
          .height(40);

        Button('ğŸ  è¿”å›é¦–é¡µ')
          .type(ButtonType.Normal)
          .backgroundColor('#FFA940')
          .fontColor('#FFFFFF')
          .onClick(() => router.push({ uri: 'pages/Index' }))
          .layoutWeight(1)
          .height(40);
      }
      .padding({ left: 16, right: 16 });

      // Big test push service button - full width
      Row() {
        Button('ğŸ”” æµ‹è¯•æ¨é€æœåŠ¡')
          .type(ButtonType.Normal)
          .backgroundColor('#0B74DE')
          .fontColor('#FFFFFF')
          .height(56)
          .layoutWeight(1)
          .borderRadius(8)
          .onClick(() => this.testPushService());
      }
      .padding({ left: 16, right: 16, top: 8, bottom: 8 });

      // å¯¼å…¥ / å¯¼å‡ºï¼ˆå¤ç”¨ä¸€ä¸ªè¾“å…¥æ¡†ï¼‰
      Column({ space: 10 }) {
        Row({ space: 8 }) {
          // æ¨¡å¼åˆ‡æ¢ï¼šå¯¼å‡º / å¯¼å…¥
          Button(this.isExportMode ? 'å¯¼å‡ºæ¨¡å¼' : 'åˆ‡åˆ°å¯¼å‡º')
            .type(ButtonType.Capsule)
            .backgroundColor(this.isExportMode ? '#1677FF' : '#E5E7EB')
            .fontColor(this.isExportMode ? '#FFFFFF' : '#333333')
            .height(32)
            .onClick(() => { this.isExportMode = true; });
          Button(!this.isExportMode ? 'å¯¼å…¥æ¨¡å¼' : 'åˆ‡åˆ°å¯¼å…¥')
            .type(ButtonType.Capsule)
            .backgroundColor(!this.isExportMode ? '#00AA66' : '#E5E7EB')
            .fontColor(!this.isExportMode ? '#FFFFFF' : '#333333')
            .height(32)
            .onClick(() => { this.isExportMode = false; });
          // æ¸…ç©º

        }

        TextArea({ placeholder: this.isExportMode ? 'å¯¼å‡ºæ•°æ® JSONï¼ˆåªè¯»ï¼‰' : 'ç²˜è´´ JSON æ•°æ®ï¼ˆå¯ç¼–è¾‘ï¼‰', text: this.ioText })
          .enabled(!this.isExportMode)
          .height(120)
          .borderColor('#E5E7EB')
          .borderWidth(1)
          .borderRadius(8)
          .padding(10);

        Row({ space: 8 }) {
          if (this.isExportMode) {
            Button('æ¸…ç©º')
              .type(ButtonType.Capsule)
              .backgroundColor('#F2F2F2')
              .fontColor('#333333')
              .height(32)
              .onClick(() => { this.ioText = ''; });
            Button('ç”Ÿæˆå¯¼å‡º')
              .type(ButtonType.Capsule)
              .backgroundColor('#1677FF')
              .fontColor('#FFFFFF')
              .height(36)
              .onClick(() => this.exportData());
            Button('å¤åˆ¶')
              .type(ButtonType.Capsule)
              .backgroundColor('#4B5563')
              .fontColor('#FFFFFF')
              .height(36)
              .onClick(() => this.copyExport());
          } else {
            Button('å¯¼å…¥æ•°æ®')
              .type(ButtonType.Capsule)
              .backgroundColor('#00AA66')
              .fontColor('#FFFFFF')
              .height(36)
              .onClick(() => this.importData());
          }
        }
      }
      .padding({ left: 16, right: 16 });

      // List of events (cards)
      List({ space: 10 }) {
        ForEach(this.events, (item: MemoryItem) => {
          ListItem() {
            EventCard({
              item: item,
              deleteTargetId: $deleteTargetId,
              onEdit: (item: MemoryItem) => this.onEdit(item),
              onDelete: (id: number) => this.onDelete(id),
              onCancelDelete: () => this.cancelDelete(),
              onPerformDelete: () => this.performDelete()
            })
          }
        })
      }
      .padding({ left: 16, right: 16, bottom: 16 })
      .width('100%')
      .height('100%')
      .edgeEffect(EdgeEffect.None)
      .layoutWeight(1);

    }
    .width('100%')
    .height('100%')
    .backgroundColor('#F7F8FA');
  }

  private triggerVibration(): void {
    try {
      // éœ‡åŠ¨æç¤º / è§¦è§‰åé¦ˆ
      vibrator.vibrate(50);
    } catch (err) {
      console.error('éœ‡åŠ¨å¤±è´¥', err);
    }
  }

  private toast(msg: string): void {
    try { promptAction.showToast({ message: msg }); } catch (_) {}
  }

  // Clear all rows in DB (developer operation)
  private async clearAll(): Promise<void> {
    try {
      this.busy = true;
      const cols: string[] = ['id'];
      const rows: Memory[] = await MemoryDBUtil.queryMemories('memories', cols);
      for (const r of rows) {
        const id = r.id ?? 0;
        if (id > 0) {
          try { await MemoryDBUtil.deleteMemoryById('memories', id); } catch (_) {}
        }
      }
      await this.loadEvents();
      this.triggerVibration();
    } catch (e) {
      console.error('clearAll failed', e);
    } finally {
      this.busy = false;
    }
  }

  // Export logs stub (developer can replace with real export)
  private async exportLogs(): Promise<void> {
    // keep the original toast behavior for export
    this.toast('å¯¼å‡ºæ—¥å¿—ï¼šå·²ç”Ÿæˆåˆ°åº”ç”¨æ²™ç®±ï¼ˆç¤ºä¾‹ï¼‰');

    // Try publishing a simple test notification (developer convenience)
    try {
      const notificationRequest: notificationManager.NotificationRequest = {
        id: (Date.now() % 100000) + 1, // small unique-ish id
        content: {
          notificationContentType: notificationManager.ContentType.NOTIFICATION_CONTENT_BASIC_TEXT,
          normal: {
            title: 'Hixy æµ‹è¯•é€šçŸ¥',
            text: 'è¿™æ˜¯æ¥è‡ªå¼€å‘è€…æ¨¡å¼çš„æµ‹è¯•é€šçŸ¥',
            additionalText: 'æ›´å¤šä¿¡æ¯å¯åœ¨æ—¥å¿—æŸ¥çœ‹'
          }
        }
      };

      await notificationManager.publish(notificationRequest);
      console.info('Succeeded in publishing notification.');
      this.toast('æµ‹è¯•é€šçŸ¥å·²å‘é€');
    } catch (err) {
      // explicit runtime narrowing using the declared interface
      if (err && typeof err === 'object') {
        const e = err as BusinessErrorLike;
        const code: number | string = (typeof e.code === 'number' || typeof e.code === 'string') ? e.code : 'unknown';
        const message: string = typeof e.message === 'string' ? e.message : String(e);
        console.error(`Failed to publish notification. Code is ${code}, message is ${message}`);
      } else {
        console.error('Failed to publish notification.', err);
      }
      this.toast('å‘é€é€šçŸ¥å¤±è´¥ï¼ˆæŸ¥çœ‹æ—¥å¿—ï¼‰');
    }
  }

  // Export current events to JSON (developer convenience)
  private exportData(): void {
    const payload: MemoryExportItem[] = (this.events || []).map((e: MemoryItem): MemoryExportItem => {
      let normalizedDate: number | string | null = null;
      if (e.date instanceof Date) {
        normalizedDate = e.date.getTime();
      } else if (typeof e.date === 'number') {
        normalizedDate = e.date;
      } else if (typeof e.date === 'string') {
        normalizedDate = e.date;
      }
      return { title: e.title, date: normalizedDate, type: e.type ?? 'countdown' } as MemoryExportItem;
    });
    this.ioText = JSON.stringify(payload);
    this.toast('å¯¼å‡ºå®Œæˆï¼Œå¯å¤åˆ¶ JSON');
  }

  // Copy export JSON to clipboard
  private async copyExport(): Promise<void> {
    const text: string = this.ioText ?? '';
    if (!text || text.length === 0) {
      this.toast('æ— å¯å¤åˆ¶å†…å®¹');
      return;
    }
    try {
      const sysPB = pasteboard.getSystemPasteboard();
      const data = pasteboard.createPlainTextData(text);
      await sysPB.setData(data);
      this.toast('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
    } catch (e) {
      console.error('copyExport failed', e);
      this.toast('å¤åˆ¶å¤±è´¥');
    }
  }

  // Import JSON array of events and insert into DB
  private async importData(): Promise<void> {
    if (!this.ioText || this.ioText.trim().length === 0) {
      this.toast('è¯·å…ˆç²˜è´´ JSON æ•°æ®');
      return;
    }
    let arr: MemoryImportItem[];
    try {
      arr = JSON.parse(this.ioText) as MemoryImportItem[];
    } catch (e) {
      console.error('importData parse failed', e);
      this.toast('å¯¼å…¥å¤±è´¥ï¼Œæ£€æŸ¥ JSON æ ¼å¼');
      return;
    }
    if (!Array.isArray(arr)) {
      this.toast('æ ¼å¼é”™è¯¯ï¼šéœ€è¦æ•°ç»„');
      return;
    }
    let count = 0;
    for (const item of arr) {
      const title: string = (item?.title ?? '').toString().trim();
      if (!title) { continue; }
      const type: MemoryType = item?.type === 'anniversary' ? 'anniversary' : 'countdown';
      const dateVal: number | string | null | undefined = item?.date;
      let dateMs: number = Date.now();
      if (typeof dateVal === 'number' && !isNaN(dateVal)) {
        dateMs = dateVal;
      } else if (typeof dateVal === 'string' && dateVal.length > 0) {
        const parsed = Date.parse(dateVal);
        if (!isNaN(parsed)) { dateMs = parsed; }
      }
      const vb: relationalStore.ValuesBucket = makeValuesBucket(title, type === 'anniversary' ? 1 : 0, dateMs);
      try {
        await MemoryDBUtil.insertMemory('memories', vb);
        count++;
      } catch (e) { console.error('import insert failed', e); }
    }
    await this.loadEvents();
    this.toast(`å¯¼å…¥å®Œæˆï¼ŒæˆåŠŸ ${count} æ¡`);
  }

  // è·³è½¬åˆ°ç¼–è¾‘é¡µ
  private onEdit(item: MemoryItem): void {
    AppStorage.Set<number>('selectedId', item.id);
    try { router.push({ uri: 'pages/EditMemory', params: { editId: item.id } }); } catch (_) {}
  }

  // æ ‡è®°å¾…åˆ é™¤é¡¹
  private onDelete(id: number): void {
    this.deleteTargetId = id;
  }

  // å–æ¶ˆåˆ é™¤
  private cancelDelete(): void {
    this.deleteTargetId = undefined;
  }

  // ç¡®è®¤åˆ é™¤
  private async performDelete(): Promise<void> {
    if (!this.deleteTargetId) { return; }
    try {
      await MemoryDBUtil.deleteMemoryById('memories', this.deleteTargetId);
      this.toast('å·²åˆ é™¤');
    } catch (e) {
      console.error('performDelete failed', e);
      this.toast('åˆ é™¤å¤±è´¥');
    } finally {
      this.deleteTargetId = undefined;
      await this.loadEvents();
    }
  }

  // ä»æ•°æ®åº“è¯»å–åˆ—è¡¨
  private async loadEvents(): Promise<void> {
    try {
      const cols: string[] = ['id', 'task_name', 'finished', 'target_date', 'content'];
      const rows: Memory[] = await MemoryDBUtil.queryMemories('memories', cols);
      this.events = (rows || []).map((r: Memory): MemoryItem => {
        const id: number = r.id ?? 0;
        const title: string = r.title ?? '';
        const date: Date | number | null = (typeof r.targetDate === 'number' && !isNaN(r.targetDate) && r.targetDate > 0)
          ? r.targetDate
          : null;
        const type: MemoryType = r.finished ? 'anniversary' : 'countdown';
        const note: string | undefined = r.content ?? undefined;
        return { id, title, date, type, note } as MemoryItem;
      });
    } catch (err) {
      console.log(`åŠ è½½è®°å¿†åˆ—è¡¨å¤±è´¥: ${err}`);
      this.events = [];
    }
  }

  // Debug helper: write a test row and query DB using MemDBUtils directly
  private async testWrite(): Promise<void> {
    const title = `Test ${Date.now()}`;
    const t = new Date(); t.setDate(t.getDate() + 1); t.setHours(0, 0, 0, 0);
    const vb: relationalStore.ValuesBucket = makeValuesBucket(title, 0, t.getTime());
    try {
      await MemoryDBUtil.insertMemory('memories', vb);
      await new Promise<void>((resolve) => setTimeout(resolve, 500));
      await this.loadEvents();
    } catch (e) {
      console.error('testWrite failed', e);
    }
  }

  // æµ‹è¯•æ¨é€æœåŠ¡ï¼ˆå‘å¸ƒé€šçŸ¥ï¼‰
  private async testPushService(): Promise<void> {
    try {
      const notificationRequest: notificationManager.NotificationRequest = {
        id: (Date.now() % 100000) + 1, // small unique-ish id
        content: {
          notificationContentType: notificationManager.ContentType.NOTIFICATION_CONTENT_BASIC_TEXT,
          normal: {
            title: 'æ¨é€æœåŠ¡æµ‹è¯•',
            text: 'è¿™æ˜¯ä¸€ä¸ªæ¥è‡ªæ¨é€æœåŠ¡çš„æµ‹è¯•é€šçŸ¥',
            additionalText: 'å¦‚èƒ½æ”¶åˆ°é€šçŸ¥ï¼Œåˆ™æ¨é€æœåŠ¡æ­£å¸¸'
          }
        }
      };

      await notificationManager.publish(notificationRequest);
      console.info('æ¨é€é€šçŸ¥å‘å¸ƒæˆåŠŸ');
      this.toast('æ¨é€é€šçŸ¥å·²å‘é€');
    } catch (err) {
      // explicit runtime narrowing using the declared interface
      if (err && typeof err === 'object') {
        const e = err as BusinessErrorLike;
        const code: number | string = (typeof e.code === 'number' || typeof e.code === 'string') ? e.code : 'unknown';
        const message: string = typeof e.message === 'string' ? e.message : String(e);
        console.error(`æ¨é€é€šçŸ¥å‘å¸ƒå¤±è´¥. Code: ${code}, Message: ${message}`);
      } else {
        console.error('æ¨é€é€šçŸ¥å‘å¸ƒå¤±è´¥', err);
      }
      this.toast('å‘é€æ¨é€é€šçŸ¥å¤±è´¥ï¼ˆæŸ¥çœ‹æ—¥å¿—ï¼‰');
    }
  }
}

@Component
struct EventCard {
  @Prop item: MemoryItem;
  @Link deleteTargetId: number | undefined;
  onEdit: (item: MemoryItem) => void = () => {};
  onDelete: (id: number) => void = () => {};
  onCancelDelete: () => void = () => {};
  onPerformDelete: () => void = () => {};

  private formatDate(d: DateLike): string {
    return formatDateUtil(d);
  }

  private triggerVibration(): void {
    try {
      vibrator.vibrate(50);
    } catch (err) {
      console.error('éœ‡åŠ¨å¤±è´¥', err);
    }
  }

  build() {
    Row({ space: 12 }) {
      Column() {
        // Title turns red when this item is pending deletion
        Text(this.item.title)
          .fontSize(16)
          .fontWeight(FontWeight.Medium)
          .fontColor(this.deleteTargetId === this.item.id ? '#FF4D4F' : '#111');
        Text(this.formatDate(this.item.date)).fontSize(12).fontColor('#666');
      }
      .layoutWeight(1)
      .alignItems(HorizontalAlign.Start)

      // If this item is pending deletion, show inline confirm/cancel
      if (this.deleteTargetId === this.item.id) {
        Row({ space: 8 }) {
          Button('âŒ')
            .type(ButtonType.Normal)
            .backgroundColor('#F2F2F2')
            .onClick(() => {
              this.onCancelDelete();
              this.triggerVibration();
            })
            .width(50)
            // .borderRadius(50);
          Button('âœ…')
            .backgroundColor('#FF4D4F')
            .fontColor('#fff')
            .onClick(() => this.onPerformDelete())
            .width(50)
            .borderRadius(50)
            .type(ButtonType.Capsule)
        }
        .justifyContent(FlexAlign.Center)

      } else {
        Row() {
          Button('âœï¸').onClick(() => this.onEdit(this.item))
            .type(ButtonType.Capsule)
            .backgroundColor('#F2F2F2')
            .width(50)
            .borderRadius(50);
          Button('ğŸ—‘ï¸')
            .type(ButtonType.Capsule)
            .onClick(() => {
              this.onDelete(this.item.id);
              this.triggerVibration();
            })
            .backgroundColor('#FF7A45')
            .fontColor('#fff')
            .width(50)
            .borderRadius(50)
        }
        .justifyContent(FlexAlign.Center)
      }
    }
    .padding(12)
    .backgroundColor(this.deleteTargetId === this.item.id ? '#FFF2F0' : Color.White)
    .borderRadius(10);
  }
}
